package lecho.lib.hellocharts.renderer;

import lecho.lib.hellocharts.Chart;
import lecho.lib.hellocharts.ChartCalculator;
import lecho.lib.hellocharts.model.Axis;
import lecho.lib.hellocharts.model.AxisValue;
import lecho.lib.hellocharts.util.Utils;
import android.content.Context;
import android.graphics.Canvas;
import android.graphics.Paint;
import android.graphics.Paint.Align;
import android.graphics.Rect;
import android.text.TextUtils;

public class AxesRenderer {
	private static final int DEFAULT_AXIS_MARGIN_DP = 4;
	private Paint mAxisTextPaint;
	private Paint mAxisLinePaint;
	private Chart mChart;
	private Context mContext;
	private int axisXValueHeight;
	private int axisXNameHeight;
	private int axisYValueWidth;
	private int axisYNameHeight;
	private int axisMargin;
	private Rect textBounds = new Rect();
	// For now don't draw lines for X axis
	// private float[] axisXDrawBuffer;
	private final AxisStops axisXStopsBuffer = new AxisStops();
	private float[] axisYDrawBuffer = new float[] {};
	private final AxisStops axisYStopsBuffer = new AxisStops();
	private int mMaxLabelWidth;
	private int mLabelHeight;

	public AxesRenderer(Context context, Chart chart) {
		mContext = context;
		mChart = chart;
		mAxisLinePaint = new Paint();
		mAxisLinePaint.setAntiAlias(true);
		mAxisLinePaint.setStyle(Paint.Style.STROKE);
		mAxisLinePaint.setStrokeWidth(1);

		mAxisTextPaint = new Paint();
		mAxisTextPaint.setAntiAlias(true);
		mAxisTextPaint.setStyle(Paint.Style.FILL);
		mAxisTextPaint.setStrokeWidth(1);
		mAxisLinePaint.setTextSize(32);

		axisMargin = Utils.dp2px(mContext, DEFAULT_AXIS_MARGIN_DP);

	}

	public void initRenderer() {
		mAxisLinePaint.setTextSize(Utils.dp2px(mContext, 16));
		mLabelHeight = (int) Math.abs(mAxisTextPaint.getFontMetrics().top);
		mMaxLabelWidth = (int) mAxisTextPaint.measureText("0000");
	}

	public int getAxisXHeight() {
		final Axis axisX = mChart.getData().getAxisX();
		axisXValueHeight = 0;
		if (!axisX.getValues().isEmpty()) {
			axisXValueHeight = Utils.sp2px(mContext, axisX.getTextSize());
		}
		axisXNameHeight = 0;
		if (!TextUtils.isEmpty(axisX.getName())) {
			axisXNameHeight = Utils.sp2px(mContext, axisX.getTextSize());
		}
		return axisXValueHeight + axisXNameHeight + axisMargin;
	}

	public int getAxisYWidth() {
		final Axis axisY = mChart.getData().getAxisY();
		mAxisTextPaint.setTextSize(Utils.sp2px(mContext, axisY.getTextSize()));
		axisYValueWidth = 0;
		if (!axisY.getValues().isEmpty()) {
			final String text;
			// to simplify I assume that the widest value will be the first or the last.
			if (Math.abs(axisY.getValues().get(0).getValue()) >= Math.abs(axisY.getValues()
					.get(axisY.getValues().size() - 1).getValue())) {
				text = axisY.getFormatter().formatValue(axisY.getValues().get(0));
			} else {
				text = axisY.getFormatter().formatValue(axisY.getValues().get(axisY.getValues().size() - 1));
			}
			if (!TextUtils.isEmpty(text)) {
				mAxisTextPaint.getTextBounds(text, 0, text.length(), textBounds);
				axisYValueWidth = textBounds.width();
			}
		}
		axisYNameHeight = 0;
		if (!TextUtils.isEmpty(axisY.getName())) {
			axisYNameHeight = Utils.sp2px(mContext, axisY.getTextSize());
		}
		return axisYValueWidth + axisYNameHeight + axisMargin;
	}

	public void draw(Canvas canvas) {
		// Draw axisY first to prevent X axis overdrawing.
		drawAxisY(canvas);
		drawAxisX(canvas);
	}

	private void drawAxisX(Canvas canvas) {
		final ChartCalculator chartCalculator = mChart.getChartCalculator();
		final Axis axisX = mChart.getData().getAxisX();
		mAxisLinePaint.setColor(axisX.getColor());
		mAxisTextPaint.setColor(axisX.getColor());
		mAxisTextPaint.setTextSize(Utils.sp2px(mContext, axisX.getTextSize()));
		mAxisTextPaint.setTextAlign(Align.CENTER);
		if (axisX.isAutoGenerated()) {
			drawAxisXAuto(canvas, chartCalculator, axisX);
		} else {
			drawAxisX(canvas, chartCalculator, axisX);
		}
		// Draw separation line
		canvas.drawLine(chartCalculator.mContentRectWithMargins.left, chartCalculator.mContentRect.bottom,
				chartCalculator.mContentRectWithMargins.right, chartCalculator.mContentRect.bottom, mAxisLinePaint);
		// Drawing axis name
		if (!TextUtils.isEmpty(axisX.getName())) {
			float baseline = chartCalculator.mContentRectWithMargins.bottom + axisXValueHeight + axisXNameHeight
					+ axisMargin;
			canvas.drawText(axisX.getName(), chartCalculator.mContentRect.centerX(), baseline, mAxisTextPaint);
		}
	}

	private void drawAxisX(Canvas canvas, ChartCalculator chartCalculator, Axis axisX) {
		if (axisX.getValues().size() > 0) {
			// drawing axis values
			float rawY = chartCalculator.mContentRectWithMargins.bottom + axisXValueHeight;
			for (AxisValue axisValue : axisX.getValues()) {
				final float value = axisValue.getValue();
				if (value >= chartCalculator.mCurrentViewport.left && value <= chartCalculator.mCurrentViewport.right) {
					final float rawX = chartCalculator.calculateRawX(axisValue.getValue());
					canvas.drawText(axisX.getFormatter().formatValue(axisValue), rawX, rawY, mAxisTextPaint);
				}
			}
		}
	}

	private void drawAxisXAuto(Canvas canvas, ChartCalculator chartCalculator, Axis axisX) {
		computeAxisStops(chartCalculator.mCurrentViewport.left, chartCalculator.mCurrentViewport.right,
				chartCalculator.mContentRect.width() / mMaxLabelWidth / 2, axisXStopsBuffer);
		mAxisTextPaint.setTextAlign(Paint.Align.CENTER);
		float rawY = chartCalculator.mContentRectWithMargins.bottom + axisXValueHeight;
		int i;
		for (i = 0; i < axisXStopsBuffer.numStops; ++i) {
			// TODO: Should I draw vertical lines for X axis, that doesn't look good but sometimes it is useful.
			float rawX = chartCalculator.calculateRawX(axisXStopsBuffer.stops[i]);
			String text = axisX.getFormatter().formatValue(new AxisValue(axisXStopsBuffer.stops[i]));
			canvas.drawText(text, rawX, rawY, mAxisTextPaint);
		}
	}

	private void drawAxisY(Canvas canvas) {
		final ChartCalculator chartCalculator = mChart.getChartCalculator();
		final Axis axisY = mChart.getData().getAxisY();
		mAxisLinePaint.setColor(axisY.getColor());
		mAxisTextPaint.setColor(axisY.getColor());
		mAxisTextPaint.setTextSize(Utils.sp2px(mContext, axisY.getTextSize()));
		mAxisTextPaint.setTextAlign(Align.RIGHT);
		// drawing axis values
		if (axisY.isAutoGenerated()) {
			drawAxisYAuto(canvas, chartCalculator, axisY);
		} else {
			drawAxisY(canvas, chartCalculator, axisY);
		}
		// drawing axis name
		mAxisTextPaint.setTextAlign(Align.CENTER);
		if (!TextUtils.isEmpty(axisY.getName())) {
			final float rawX = chartCalculator.mContentRectWithMargins.left - axisYValueWidth - axisMargin;
			canvas.save();
			canvas.rotate(-90, chartCalculator.mContentRect.centerY(), chartCalculator.mContentRect.centerY());
			canvas.drawText(axisY.getName(), chartCalculator.mContentRect.centerY(), rawX, mAxisTextPaint);
			canvas.restore();
		}
	}

	public void drawAxisY(Canvas canvas, ChartCalculator chartCalculator, Axis axisY) {
		if (axisYDrawBuffer.length < axisY.getValues().size() * 4) {
			axisYDrawBuffer = new float[axisY.getValues().size() * 4];
		}
		float rawX = chartCalculator.mContentRectWithMargins.left;
		int i = 0;
		for (AxisValue axisValue : axisY.getValues()) {
			final float value = axisValue.getValue();
			if (value <= chartCalculator.mCurrentViewport.bottom && value >= chartCalculator.mCurrentViewport.top) {
				final float rawY = chartCalculator.calculateRawY(value);
				axisYDrawBuffer[i++] = rawX;
				axisYDrawBuffer[i++] = rawY;
				axisYDrawBuffer[i++] = chartCalculator.mContentRectWithMargins.right;
				axisYDrawBuffer[i++] = rawY;

				canvas.drawText(axisY.getFormatter().formatValue(axisValue), rawX, rawY, mAxisTextPaint);
			}
		}
		canvas.drawLines(axisYDrawBuffer, 0, i, mAxisLinePaint);
	}

	public void drawAxisYAuto(Canvas canvas, ChartCalculator chartCalculator, Axis axisY) {
		computeAxisStops(chartCalculator.mCurrentViewport.top, chartCalculator.mCurrentViewport.bottom,
				chartCalculator.mContentRect.height() / mLabelHeight / 2, axisYStopsBuffer);
		if (axisYDrawBuffer.length < axisYStopsBuffer.numStops * 4) {
			axisYDrawBuffer = new float[axisYStopsBuffer.numStops * 4];
		}
		float rawX = chartCalculator.mContentRectWithMargins.left;
		int i;
		for (i = 0; i < axisYStopsBuffer.numStops; i++) {
			final float rawY = chartCalculator.calculateRawY(axisYStopsBuffer.stops[i]);
			axisYDrawBuffer[i * 4 + 0] = rawX;
			axisYDrawBuffer[i * 4 + 1] = rawY;
			axisYDrawBuffer[i * 4 + 2] = chartCalculator.mContentRectWithMargins.right;
			axisYDrawBuffer[i * 4 + 3] = rawY;
			canvas.drawText(axisY.getFormatter().formatValue(new AxisValue(axisYStopsBuffer.stops[i])), rawX, rawY,
					mAxisTextPaint);
		}
		canvas.drawLines(axisYDrawBuffer, 0, axisYStopsBuffer.numStops * 4, mAxisLinePaint);
	}

	/**
	 * Computes the set of axis labels to show given start and stop boundaries and an ideal number of stops between
	 * these boundaries.
	 * 
	 * @param start
	 *            The minimum extreme (e.g. the left edge) for the axis.
	 * @param stop
	 *            The maximum extreme (e.g. the right edge) for the axis.
	 * @param steps
	 *            The ideal number of stops to create. This should be based on available screen space; the more space
	 *            there is, the more stops should be shown.
	 * @param outStops
	 *            The destination {@link AxisStops} object to populate.
	 */
	private static void computeAxisStops(float start, float stop, int steps, AxisStops outStops) {
		double range = stop - start;
		if (steps == 0 || range <= 0) {
			outStops.stops = new float[] {};
			outStops.numStops = 0;
			return;
		}

		double rawInterval = range / steps;
		double interval = Utils.roundToOneSignificantFigure(rawInterval);
		double intervalMagnitude = Math.pow(10, (int) Math.log10(interval));
		int intervalSigDigit = (int) (interval / intervalMagnitude);
		if (intervalSigDigit > 5) {
			// Use one order of magnitude higher, to avoid intervals like 0.9 or 90
			interval = Math.floor(10 * intervalMagnitude);
		}

		double first = Math.ceil(start / interval) * interval;
		double last = Utils.nextUp(Math.floor(stop / interval) * interval);

		double intervalValue;
		int stopIndex;
		int numStops = 0;
		for (intervalValue = first; intervalValue <= last; intervalValue += interval) {
			++numStops;
		}

		outStops.numStops = numStops;

		if (outStops.stops.length < numStops) {
			// Ensure stops contains at least numStops elements.
			outStops.stops = new float[numStops];
		}

		for (intervalValue = first, stopIndex = 0; stopIndex < numStops; intervalValue += interval, ++stopIndex) {
			outStops.stops[stopIndex] = (float) intervalValue;
		}

		if (interval < 1) {
			outStops.decimals = (int) Math.ceil(-Math.log10(interval));
		} else {
			outStops.decimals = 0;
		}
	}

	/**
	 * A simple class representing axis label values used only for auto generated axes.
	 * 
	 */
	private static class AxisStops {
		float[] stops = new float[] {};
		int numStops;
		int decimals;
	}
}
