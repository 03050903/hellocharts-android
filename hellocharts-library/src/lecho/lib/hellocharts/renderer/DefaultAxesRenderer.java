package lecho.lib.hellocharts.renderer;

import lecho.lib.hellocharts.Chart;
import lecho.lib.hellocharts.ChartComputator;
import lecho.lib.hellocharts.model.Axis;
import lecho.lib.hellocharts.model.AxisValue;
import lecho.lib.hellocharts.util.Utils;
import android.content.Context;
import android.graphics.Canvas;
import android.graphics.Paint;
import android.graphics.Paint.Align;
import android.graphics.Paint.FontMetricsInt;
import android.text.TextUtils;

/**
 * Default axes renderer. Draws X axis below chart and Y axis on the left.
 */
public class DefaultAxesRenderer implements AxesRenderer {
	private static final int DEFAULT_AXIS_MARGIN_DP = 4;
	private static final int TOP = 0;
	private static final int LEFT = 1;
	private static final int RIGHT = 2;
	private static final int BOTTOM = 3;
	private Paint textPaint;
	private Paint linePaint;
	private Chart chart;
	private int axisMargin;
	// For now don't draw lines for X axis
	// private float[] axisXDrawBuffer;
	private final AxisStops axisXStopsBuffer = new AxisStops();
	private float[] axisYDrawBuffer = new float[] {};
	private final AxisStops axisYStopsBuffer = new AxisStops();
	private int axesLabelMaxWidth;
	private int axesTextHeight;
	private FontMetricsInt fontMetrics = new FontMetricsInt();
	private char[] labelBuffer = new char[32];
	private static final char[] labelWidthChars = new char[] { '0', '0', '0', '0', '0', '0', '0', '0', '0', '0', '0',
			'0', '0', '0', '0', '0', '0', '0', '0', '0', '0', '0', '0', '0', '0', '0', '0', '0', '0', '0', '0', '0' };

	private float density;
	private float scaledDensity;

	public DefaultAxesRenderer(Context context, Chart chart) {
		this.chart = chart;
		density = context.getResources().getDisplayMetrics().density;
		scaledDensity = context.getResources().getDisplayMetrics().scaledDensity;
		axisMargin = Utils.dp2px(density, DEFAULT_AXIS_MARGIN_DP);

		linePaint = new Paint();
		linePaint.setAntiAlias(true);
		linePaint.setStyle(Paint.Style.STROKE);
		linePaint.setStrokeWidth(1);

		textPaint = new Paint();
		textPaint.setAntiAlias(true);
		textPaint.setStyle(Paint.Style.FILL);
		textPaint.setStrokeWidth(1);
	}

	@Override
	public void initAxesMeasurements() {
		linePaint.setColor(chart.getChartData().getAxesColor());
		textPaint.setColor(chart.getChartData().getAxesColor());
		textPaint.setTextSize(Utils.sp2px(scaledDensity, chart.getChartData().getAxesLabelTextSize()));
		textPaint.getFontMetricsInt(fontMetrics);
		int axisXBottomHeight = getAxisXHeight(chart.getChartData().getAxisXBottom());
		int axisXTopHeight = getAxisXHeight(chart.getChartData().getAxisXTop());
		int axisYLeftWidth = getAxisYWidth(chart.getChartData().getAxisYLeft(), chart.getChartData()
				.getMaxAxisLabelChars());
		int axisYRightWidth = getAxisYWidth(chart.getChartData().getAxisYRight(), chart.getChartData()
				.getMaxAxisLabelChars());

		chart.getChartComputator().setAxesMargin(axisYLeftWidth, axisXTopHeight, axisYRightWidth, axisXBottomHeight);
	}

	private int getAxisXHeight(Axis axisX) {
		axesTextHeight = Math.abs(fontMetrics.ascent);
		int result = 0;

		if (axisX.isAutoGenerated() || !axisX.getValues().isEmpty()) {
			result += axesTextHeight;
		}

		if (!TextUtils.isEmpty(axisX.getName())) {
			result += axesTextHeight;
		}

		if (result > 0) {
			result += axisMargin;
		}

		return result;
	}

	private int getAxisYWidth(Axis axisY, int maxLabelChars) {
		int result = 0;

		if (axisY.isAutoGenerated()) {
			axesLabelMaxWidth = (int) textPaint.measureText(labelWidthChars, 0, maxLabelChars);
			result += axesLabelMaxWidth;
		} else if (!axisY.getValues().isEmpty()) {
			final int numChars;
			// to simplify I assume that the widest value will be the first or the last.
			if (Math.abs(axisY.getValues().get(0).getValue()) >= Math.abs(axisY.getValues()
					.get(axisY.getValues().size() - 1).getValue())) {
				numChars = axisY.getFormatter().formatValue(labelBuffer, axisY.getValues().get(0).getValue());
			} else {
				numChars = axisY.getFormatter().formatValue(labelBuffer,
						axisY.getValues().get(axisY.getValues().size() - 1).getValue());
			}
			if (numChars > 0) {
				axesLabelMaxWidth = (int) textPaint.measureText(labelBuffer, labelBuffer.length - numChars, numChars);
				result += axesLabelMaxWidth;
			}
		}
		if (!TextUtils.isEmpty(axisY.getName())) {
			axesTextHeight = Math.abs(fontMetrics.ascent);
			result += axesTextHeight;
		}

		if (result > 0) {
			result += axisMargin;
		}

		return result;
	}

	@Override
	public void draw(Canvas canvas) {
		// Draw axisY first to prevent X axis overdrawing.
		drawAxisY(canvas, LEFT);
		drawAxisY(canvas, RIGHT);
		drawAxisX(canvas, BOTTOM);
		drawAxisX(canvas, TOP);
	}

	private void drawAxisX(Canvas canvas, int position) {
		final ChartComputator computator = chart.getChartComputator();
		textPaint.setTextAlign(Align.CENTER);

		final Axis axisX;
		final float rawY;
		final float nameBaseline;
		final float separationBaseline;

		if (BOTTOM == position) {
			axisX = chart.getChartData().getAxisXBottom();
			rawY = computator.getContentRectWithMargins().bottom + axesTextHeight;
			nameBaseline = computator.getContentRectWithMargins().bottom + 2 * axesTextHeight + axisMargin;
			separationBaseline = computator.getContentRect().bottom;
		} else if (TOP == position) {
			axisX = chart.getChartData().getAxisXTop();
			rawY = computator.getContentRectWithMargins().top;
			nameBaseline = computator.getContentRectWithMargins().top - axesTextHeight - axisMargin;
			separationBaseline = computator.getContentRect().top;
		} else {
			throw new IllegalArgumentException("Invalid position for X axis: " + position);
		}

		if (axisX.isAutoGenerated()) {
			drawAxisXAuto(canvas, computator, axisX, rawY);
		} else {
			drawAxisX(canvas, computator, axisX, rawY);
		}
		// Drawing axis name
		if (!TextUtils.isEmpty(axisX.getName())) {
			canvas.drawText(axisX.getName(), computator.getContentRect().centerX(), nameBaseline, textPaint);
		}
		if (axisX.isAutoGenerated() || !axisX.getValues().isEmpty() || !TextUtils.isEmpty(axisX.getName())) {
			// Draw separation line
			canvas.drawLine(computator.getContentRectWithMargins().left, separationBaseline,
					computator.getContentRectWithMargins().right, separationBaseline, linePaint);
		}
	}

	private void drawAxisX(Canvas canvas, ChartComputator computator, Axis axisX, float rawY) {
		if (axisX.getValues().size() > 0) {
			// drawing axis values
			for (AxisValue axisValue : axisX.getValues()) {
				final float value = axisValue.getValue();
				if (value >= computator.getVisibleViewport().left && value <= computator.getVisibleViewport().right) {
					final float rawX = computator.computeRawX(axisValue.getValue());
					final int nummChars = axisX.getFormatter().formatValue(labelBuffer, axisValue.getValue());
					canvas.drawText(labelBuffer, labelBuffer.length - nummChars, nummChars, rawX, rawY, textPaint);
				}
			}
		}
	}

	private void drawAxisXAuto(Canvas canvas, ChartComputator computator, Axis axisX, float rawY) {
		computeAxisStops(computator.getVisibleViewport().left, computator.getVisibleViewport().right, computator
				.getContentRect().width() / axesLabelMaxWidth / 2, axisXStopsBuffer);
		int i;
		for (i = 0; i < axisXStopsBuffer.numStops; ++i) {
			// TODO: Should I draw vertical lines for X axis, that doesn't look good but sometimes it is useful.
			float rawX = computator.computeRawX(axisXStopsBuffer.stops[i]);
			final int nummChars = axisX.getFormatter().formatValue(labelBuffer, axisXStopsBuffer.stops[i],
					axisXStopsBuffer.decimals);
			canvas.drawText(labelBuffer, labelBuffer.length - nummChars, nummChars, rawX, rawY, textPaint);
		}
	}

	private void drawAxisY(Canvas canvas, int position) {
		final ChartComputator computator = chart.getChartComputator();

		final Axis axisY;
		final float rawX;
		final float nameBaseline;

		if (LEFT == position) {
			axisY = chart.getChartData().getAxisYLeft();
			textPaint.setTextAlign(Align.RIGHT);
			rawX = computator.getContentRectWithMargins().left;
			nameBaseline = computator.getContentRectWithMargins().left - axesLabelMaxWidth - axisMargin;
		} else if (RIGHT == position) {
			textPaint.setTextAlign(Align.LEFT);
			axisY = chart.getChartData().getAxisYRight();
			rawX = computator.getContentRectWithMargins().right;
			nameBaseline = computator.getContentRectWithMargins().right + axesLabelMaxWidth + axisMargin
					+ axesTextHeight;
		} else {
			throw new IllegalArgumentException("Invalid position for Y axis: " + position);
		}

		// drawing axis values
		if (axisY.isAutoGenerated()) {
			drawAxisYAuto(canvas, computator, axisY, rawX);
		} else {
			drawAxisY(canvas, computator, axisY, rawX);
		}
		// drawing axis name
		textPaint.setTextAlign(Align.CENTER);
		if (!TextUtils.isEmpty(axisY.getName())) {
			canvas.save();
			canvas.rotate(-90, computator.getContentRect().centerY(), computator.getContentRect().centerY());
			canvas.drawText(axisY.getName(), computator.getContentRect().centerY(), nameBaseline, textPaint);
			canvas.restore();
		}
	}

	private void drawAxisY(Canvas canvas, ChartComputator computator, Axis axisY, float rawX) {
		if (axisYDrawBuffer.length < axisY.getValues().size() * 4) {
			axisYDrawBuffer = new float[axisY.getValues().size() * 4];
		}
		int i = 0;
		for (AxisValue axisValue : axisY.getValues()) {
			final float value = axisValue.getValue();
			if (value >= computator.getVisibleViewport().bottom && value <= computator.getVisibleViewport().top) {
				final float rawY = computator.computeRawY(value);
				axisYDrawBuffer[i++] = rawX;
				axisYDrawBuffer[i++] = rawY;
				axisYDrawBuffer[i++] = computator.getContentRectWithMargins().right;
				axisYDrawBuffer[i++] = rawY;
				final int nummChars = axisY.getFormatter().formatValue(labelBuffer, axisValue.getValue());
				canvas.drawText(labelBuffer, labelBuffer.length - nummChars, nummChars, rawX, rawY, textPaint);
			}
		}
		canvas.drawLines(axisYDrawBuffer, 0, i, linePaint);
	}

	private void drawAxisYAuto(Canvas canvas, ChartComputator computator, Axis axisY, float rawX) {
		computeAxisStops(computator.getVisibleViewport().bottom, computator.getVisibleViewport().top, computator
				.getContentRect().height() / axesTextHeight / 2, axisYStopsBuffer);

		if (axisYDrawBuffer.length < axisYStopsBuffer.numStops * 4) {
			axisYDrawBuffer = new float[axisYStopsBuffer.numStops * 4];
		}

		int i;
		for (i = 0; i < axisYStopsBuffer.numStops; i++) {
			final float rawY = computator.computeRawY(axisYStopsBuffer.stops[i]);
			axisYDrawBuffer[i * 4 + 0] = rawX;
			axisYDrawBuffer[i * 4 + 1] = rawY;
			axisYDrawBuffer[i * 4 + 2] = computator.getContentRectWithMargins().right;
			axisYDrawBuffer[i * 4 + 3] = rawY;
			final int nummChars = axisY.getFormatter().formatValue(labelBuffer, axisYStopsBuffer.stops[i],
					axisYStopsBuffer.decimals);
			canvas.drawText(labelBuffer, labelBuffer.length - nummChars, nummChars, rawX, rawY, textPaint);
		}
		canvas.drawLines(axisYDrawBuffer, 0, axisYStopsBuffer.numStops * 4, linePaint);
	}

	/**
	 * Computes the set of axis labels to show given start and stop boundaries and an ideal number of stops between
	 * these boundaries.
	 * 
	 * @param start
	 *            The minimum extreme (e.g. the left edge) for the axis.
	 * @param stop
	 *            The maximum extreme (e.g. the right edge) for the axis.
	 * @param steps
	 *            The ideal number of stops to create. This should be based on available screen space; the more space
	 *            there is, the more stops should be shown.
	 * @param outStops
	 *            The destination {@link AxisStops} object to populate.
	 */
	private static void computeAxisStops(float start, float stop, int steps, AxisStops outStops) {
		double range = stop - start;
		if (steps == 0 || range <= 0) {
			outStops.stops = new float[] {};
			outStops.numStops = 0;
			return;
		}

		double rawInterval = range / steps;
		double interval = Utils.roundToOneSignificantFigure(rawInterval);
		double intervalMagnitude = Math.pow(10, (int) Math.log10(interval));
		int intervalSigDigit = (int) (interval / intervalMagnitude);
		if (intervalSigDigit > 5) {
			// Use one order of magnitude higher, to avoid intervals like 0.9 or 90
			interval = Math.floor(10 * intervalMagnitude);
		}

		double first = Math.ceil(start / interval) * interval;
		double last = Utils.nextUp(Math.floor(stop / interval) * interval);

		double intervalValue;
		int stopIndex;
		int numStops = 0;
		for (intervalValue = first; intervalValue <= last; intervalValue += interval) {
			++numStops;
		}

		outStops.numStops = numStops;

		if (outStops.stops.length < numStops) {
			// Ensure stops contains at least numStops elements.
			outStops.stops = new float[numStops];
		}

		for (intervalValue = first, stopIndex = 0; stopIndex < numStops; intervalValue += interval, ++stopIndex) {
			outStops.stops[stopIndex] = (float) intervalValue;
		}

		if (interval < 1) {
			outStops.decimals = (int) Math.ceil(-Math.log10(interval));
		} else {
			outStops.decimals = 0;
		}
	}

	/**
	 * A simple class representing axis label values used only for auto generated axes.
	 * 
	 */
	private static class AxisStops {
		float[] stops = new float[] {};
		int numStops;
		int decimals;
	}
}
